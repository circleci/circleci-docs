---
description: Open preview of config policy management for CircleCI
contentTags: 
  platform:
  - Cloud
---
= Config policy reference
:page-layout: classic-docs
:page-liquid:
:icons: font
:toc: macro
:toc-title:

NOTE: Config policy management is available on the **Scale** plan and is currently in **open preview**. All aspects of the feature are subject to change.

CAUTION: While config policy management is in open preview stage, it should **not** be used for compliance purposes. The feature might become unavailable occasionally during **open preview**, during which build configurations may **not** be evaluated against policies.

This reference page lists a selection of _helpers_, or CircleCI-specific funtions that are likely to be useful for you when you are writing your policies. These helpers will lead to _cleaner_ policies with less boilerplate.

The `circle-policy-agent` package includes built-in functions for common config policy
use cases. All policies evaluated by the `policy-service`, the `circle-cli`, or the `circle-policy-agent`
will be able to access these functions. This also means the package name `circleci.config` is
reserved.

[#circleci-rego-helpers]
== CircleCI rego helpers

[#orbs]
=== `orbs`

`orbs` is a Rego object containing orbs and versions present in the given config file. It 
can be utilized by policies related to orbs.

[#definition-orbs]
==== Definition

[source,rego]
----
orbs[string] = string
----

Example `orbs` object:

[source,json]
----
{
    "circleci/security": "1.2.3",
    "circleci/foo": "3.2.1"
}
----

[#usage-orbs]
==== Usage

[source,rego]
----
package org

import data.circleci.config

policy_name["example"]

my_orbs := config.orbs
----

[#ban-orbs]
=== `ban_orbs`

This function violates a policy if a config includes orbs based on the orb name. Versions should not 
be included in the provided list of orbs.

[#definition-ban-orbs]
==== Definition

[source,rego]
----
ban_orbs_version([string])
returns { string: string }
----

[#usage-ban-orbs]
==== Usage

[source,rego]
----
package org

import data.circleci.config

policy_name["example"]

ban_orbs = config.ban_orbs(["evilcorp/evil"])

enable_rule["ban_orbs"]

hard_fail["ban_orbs"]
----

[#ban-orbs-version]
=== `ban_orbs_version`

This function violates a policy if a config includes orbs based on the orb name and version.

[#definition-ban-orbs-version]
==== Definition

[source,rego]
----
ban_orbs_version([string])
returns { string: string }
----

[#usage-ban-orbs-version]
==== Usage

[source,rego]
----
package org

import data.circleci.config

policy_name["example"]

ban_orbs_versioned = config.ban_orbs_version(["evilcorp/evil@1.2.3", "foo/bar@4.5.6"])

enable_rule["ban_orbs_versioned"]

hard_fail["ban_orbs_versioned"]
----

[#resource-class-by-project]
=== `resource_class_by_project`

This function accepts a resource class to project IDs set mapping. The resource classes defined in the
mapping will be reserved for its associated projects. Resource classes not included in the mapping will
still be available for use by any project.

[#definition-resource-class-by-project]
==== Definition

```rego
resource_class_by_project({
  "$RESOURCE_CLASS": {$PROJECT_IDS...},
  ...
})
returns { ...reasons: string }
```

[#usage-resource-class-by-project]
==== Usage

[source,rego]
----
package org

import future.keywords
import data.circleci.config

policy_name["example"]

check_resource_class = config.resource_class_by_project({
  "large": {"$PROJECT_UUID_A","$PROJECT_UUID_B"},
})

enable_rule["check_resource_class"]

hard_fail["check_resource_class"]
----







[#contexts-allowed-by-project-ids]
=== `contexts_allowed_by_project_ids`

This function accepts project ids (`PROJECTS`) as one of the following types string/set-of-strings/array-of-strings and 
context names (`ALLOWED_CONTEXTS`) as one of string/set-of-strings/array-of-strings types.
It prevents the usage of ANY context NOT IN `ALLOWED_CONTEXTS` for ALL projects that are IN `PROJECTS`.

[#definition-contexts-allowed-by-project-ids]
==== Definition

[source,rego]
----
contexts_allowed_by_project_ids(
  PROJECTS: string | Array<string> | Set<string>
  ALLOWED_CONTEXTS: string | Array<string> | Set<string>
)
returns reason <type string>
----

[#usage-contexts-allowed-by-project-ids]
==== Usage

[source,rego]
----
package org

import future.keywords
import data.circleci.config

policy_name["a_unique_policy_name"]

rule_contexts_allowed_by_project_ids = config.contexts_allowed_by_project_ids(
  ["${PROJECT_1_UUID}","${PROJECT_2_UUID}"],
  ["${ALLOWED_CONTEXT_NAME_1}","${ALLOWED_CONTEXT_NAME_2}"]
)

enable_rule["rule_contexts_allowed_by_project_ids"]

hard_fail["rule_contexts_allowed_by_project_ids"]
----


[#contexts-blocked-by-project-ids]
=== `contexts_blocked_by_project_ids`

This function accepts project ids (`PROJECTS`) as one of the following types string/set-of-strings/array-of-strings and 
context names (`BLOCKED_CONTEXTS`) as one of string/set-of-strings/array-of-strings types.
It blocks the usage of ANY context IN `BLOCKED_CONTEXTS` for ALL projects IN `PROJECTS`.

[#definition-contexts-blocked-by-project-ids]
==== Definition

[source,rego]
----
contexts_blocked_by_project_ids(
  PROJECTS: string | Array<string> | Set<string>
  BLOCKED_CONTEXTS: string | Array<string> | Set<string>
)
returns reason: string
----

[#usage-contexts-blocked-by-project-ids]
==== Usage

[source,rego]
----
package org

import future.keywords
import data.circleci.config

policy_name["a_unique_policy_name"]

rule_contexts_blocked_by_project_ids = config.contexts_blocked_by_project_ids(
  ["${PROJECT_1_UUID}","${PROJECT_2_UUID}"],
  ["${BLOCKED_CONTEXT_1}","${BLOCKED_CONTEXT_2}"]
)

enable_rule["rule_contexts_blocked_by_project_ids"]

hard_fail["rule_contexts_blocked_by_project_ids"]
----


[#contexts-reserved-by-project-ids]
=== `contexts_reserved_by_project_ids`

This function accepts project ids (`PROJECTS`) as one of the following types string/set-of-strings/array-of-strings and 
context names (`RESERVED_CONTEXTS`) as one of string/set-of-strings/array-of-strings types.
It blocks the usage of ANY context IN `RESERVED_CONTEXTS` for ALL projects NOT IN `PROJECTS`.

[#definition-contexts-reserved-by-project-ids]
==== Definition

[source,rego]
----
contexts_reserved_by_project_ids(
  PROJECTS: string | Array<string> | Set<string>
  RESERVED_CONTEXTS: string | Array<string> | Set<string>
)
returns reason: string
----

[#usage-contexts-reserved-by-project-ids]
==== Usage

[source,rego]
----
package org

import future.keywords
import data.circleci.config

policy_name["a_unique_policy_name"]

rule_contexts_reserved_by_project_ids = config.contexts_reserved_by_project_ids(
  ["${PROJECT_1_UUID}","${PROJECT_2_UUID}"],
  ["${RESERVED_CONTEXT_1}","${RESERVED_CONTEXT_2}"]
)

enable_rule["rule_contexts_reserved_by_project_ids"]

hard_fail["rule_contexts_reserved_by_project_ids"]
----


[#contexts-reserved-by-branches]
=== `contexts_reserved_by_branches`

This function accepts VCS branch names (`BRANCHES`) as one of the following types string/set-of-strings/array-of-strings and
context names (`RESERVED_CONTEXTS`) as one of string/set-of-strings/array-of-strings types.
Branch names NOT IN `BRANCHES` are NOT allowed to use the contexts IN `RESERVED_CONTEXTS`, however other contexts may be used.

[#definition-contexts-reserved-by-branches]
==== Definition

[source,rego]
----
contexts_reserved_by_branches(
  BRANCHES: string | Array<string> | Set<string>
  CONTEXT_LIST: string | Array<string> | Set<string>
)
returns reason: string
----

[#usage-contexts-reserved-by-branches]
==== Usage

[source,rego]
----
package org

import future.keywords
import data.circleci.config

policy_name["a_unique_policy_name"]

rule_contexts_reserved_by_branches = config.contexts_reserved_by_branches(
   ["${BRANCH_1}, "${BRANCH_2}", "${BRANCH_3}"]",
  ["${RESERVED_CONTEXT_1}","${RESERVED_CONTEXT_2}"]
)

enable_rule["rule_contexts_reserved_by_branches"]

hard_fail["rule_contexts_reserved_by_branches"]
----