---
redirect_from: /configuration-cookbook/
contentTags: 
  platform:
  - Cloud
  - Server v4.x
  - Server v3.x
  - Server v2.x
---
= Configuration Introduction
:page-layout: classic-docs
:page-liquid:
:page-description: "Learn how to get started with the CircleCI config.yml file."
:icons: font
:toc: macro
:toc-title:

This guide gets you started with the CircleCI `config.yml` file.

toc::[]

[#getting-started-with-circleci-config]
== Getting started with CircleCI config

This guide covers the following topics:

* How CircleCI finds and runs `config.yml`.
* How you can use shell commands to perform actions.
* How `config.yml` interacts with your code.
* How to trigger a build.
* How to use Docker containers to run your jobs in a specific environment.
* How to use workflows to orchestrate your build.
* How to add approval steps to your workflow.

CircleCI believes in *configuration as code*. Consequently, the entire delivery process from build to deploy is orchestrated through a single file called `config.yml`. The `config.yml` file is located in a folder called `.circleci` at the top of your repo project. CircleCI uses the YAML syntax for config. See the <<writing-yaml#,Writing YAML>> document for guidance on the basics.

[#part-1-using-the-shell]
== Part 1: Using the shell

CircleCI provides an on-demand shell to run commands. In this first example, you will set up a build and execute a shell command.

. If you have not done so already, <<first-steps#,sign up with CircleCI>> and select your Version Control System (VCS). You can also sign up with email.
. Create a `.circleci` folder at the root of your project. Make sure the folder starts with a period so that CircleCI can identify it.  
. Create a `config.yml` file inside the `.circleci` folder and paste the following code:
+
[source,yaml]
----
version: 2.1
jobs:
  build:
    docker:
      - image: alpine:3.15
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
    steps:
      - run:
          name: The First Step
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'
----
+
The following commentary describes what occurs in each line of the sample code:
+
* *Line 1:* This indicates the version of the CircleCI platform you are using. `2.1` is the most recent version.
* *Line 2:* The `jobs` level contains a collection of children, representing your jobs. You specify the names for these jobs, for example, _build_, _test_, _deploy_.
* *Line 3:* `build` is the first child in the `jobs` collection. In this example, `build` is also the only job.
* *Line 4:* This specifies that you are using a Docker image for the container where your job's commands are run.
* *Line 5:* This is the Docker image. The example shows `alpine:3.15`, a minimal image based on Alpine Linux.
* *Lines 6-8:* Supply your Docker registry credentials. This section is optional. For further information see the link:/docs/private-images[Using Docker Authenticated Pulls] page.
* *Line 9:* The `steps` collection is a list of `run` directives.
* *Line 10:* Each `run` directive is executed in the order in which it is declared.
* *Line 11:* The `name` attribute provides useful information when returning warnings, errors, and output. The `name` should be meaningful to you as an action within your build process.
* *Line 12:* The `command` attribute is a list of shell commands that you want to execute. The initial pipe, `|`, indicates there will be multiple lines of shell commands.
* *Line 13:* Prints `Hello World!` in your build shell.
* *Line 14:* Prints `This is the delivery pipeline`.
+
. Commit your `config.yml` file (and push, if you are working remotely).
. On the Projects page in CircleCI, find your project and click the blue *Set Up Project* button next to it.
+
image::config-set-up-project.png[Set up Project]
+
TIP: In your Version Control System (VCS), make sure you have authorized access to the project you want to manage with CircleCI (in GitHub, you have the option to block CircleCI from accessing your private repositories).
+
. In the pop-up window, choose the default *Fastest* option for selecting your `config.yml` file. Then type the name of the branch on which you committed it. If you followed steps 2 and 3, you will see a green tick to confirm that CircleCI has located a `config.yml` file in the `.circleci` directory of your project. Now click the blue *Set Up Project* button.
+
image::config-select-config-file.png[Select config file]
+ 
. CircleCI uses your `config.yml` file to run the pipeline. You can see the output in the CircleCI dashboard. A green tick denotes a successful pipeline. A red exclamation mark alerts you to a failure. Click on the job for more details.
+
image::config-intro-part1-job.png[Successful build job]
+
You should see your step - The First Step - with the the output of the commands:
+
image:config-first-step.png[Successful step within job]

NOTE: Although the `config.yml` syntax itself is straightforward, the indentation is more complicated. Incorrect indentation is the most common error. If you are experiencing problems with this example, check your indentation carefully, or copy and paste the sample code.

[#part-2-using-code-from-your-repo]
== Part 2: Using code from your repo

CircleCI provides several commands to simplify complex actions. In this example, you will use the `checkout` command. This command fetches the code from your git repo. Once you have retrieved that code, you can work with it in subsequent steps.

If you have not done so already, create a `.circleci` directory in your project, add a `config.yml` file, and type or paste the code from the example below.

If you already have a `config.yml` file from the example above, here are the changes you need to make:

* On Line 5, change the image to `cimg/base:2021.04`.
* On Line 7, add a `checkout` command.
* Add another run step (lines 13-17) at the end.

Make sure you observe the indentation.

[source,yaml]
----
version: 2.1
jobs:
  build:
    docker:
      - image: cimg/base:2021.04
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
    steps:
      - checkout
      - run:
          name: The First Step
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'
      - run:
          name: The Second Step
          command: |
            ls -al
            echo '^^^The files in your repo^^^'
----

These two small changes have significantly increased the functionality of your config file:

* *Line 5:* This line now specifies a Docker image that supports git. `cimg/base:2021.04` is a small Ubuntu-based image for running basic jobs.
* *Line 10:* The `checkout` command fetches the code from your git repo.
* *Lines 16-20:* This second step in the `build` job is listing (using `ls -al`) the contents of the repo that has been checked out. You can now perform further actions on this repo.

As before, commit and push your updated `config.yml` file.

You should now see some additional steps on the CircleCI dashboard:

* *Checkout code* has cloned the code from your git repository.
* *The Second Step* has listed the files found in your git repository.

image::config-second-step.png[Checking out your repo]

[#part-3-using-different-environments-and-creating-workflows]
== Part 3: Using different environments and creating workflows

In Parts 1 and 2, you ran your job in basic Linux-based Docker containers.

With CircleCI, you can run different jobs in different execution environments, such as virtual machines or Docker containers. By changing the Docker image, you can quickly upgrade your environment version or change languages.

In this part, you will create additional jobs and run them using different Docker images.

If you have not done so already, create a `.circleci` directory in your project, add a `config.yml` file, and type or paste the code from the example below.

[source,yaml]
----
version: 2.1
jobs:
  # running commands on a basic image
  Hello-World:
    docker:
      - image: cimg/base:2021.04
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
    steps:
      - run:
          name: Saying Hello
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'
  # fetching code from the repo
  Fetch-Code:
    docker:
      - image: cimg/base:2021.04
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
    steps:
      - checkout
      - run:
          name: Getting the Code
          command: |
            ls -al
            echo '^^^Your repo files^^^'
  # running a node container
  Using-Node:
    docker:
      - image: cimg/node:17.2
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
    steps:
      - run:
          name: Running the Node Container
          command: |
            node -v
workflows:
  Example-Workflow:
    jobs:
      - Hello-World
      - Fetch-Code:
          requires:
            - Hello-World
      - Using-Node:
          requires:
            - Fetch-Code
----

This example is more complicated than the others, but it introduces several important concepts. Parts 1 and 2 included just one job called _build_, which contained several steps. This example includes three jobs. By separating those steps into jobs, you can run each of them in a different environment.

The following commentary describes what occurs in each line of the sample code:

* *Line 3:* You can add comments to your config.yml file by preceding them with the # (hash) sign.
* *Lines 4-15:* The first job is _Hello-World_. As in Part 1, it runs two commands in a basic image.
* *Line 17:* The second job is _Fetch-Code_. It is indented to align with the _Hello-World_ job.
* *Lines 18-19:* The _Fetch-Code_ job uses a basic git-compatible image.
* *Lines 23-29:* This code is repeated from Part 2, but now it is a separate job.
* *Line 31:* The third job is _Using-Node_.
* *Lines 32-33:* This _Using-Node_ job uses a Docker image called `cimg/node:17.2`. This image contains version 17.2 of Node, along with a browser and other useful tools.
* *Lines 37-41:* As in the previous jobs, there is a _run_ step. This time, the command `node -v` prints the version of Node running in the container.
* *Lines 42-43:* This line creates a Workflow called _Example-Workflow_. Workflows define a list of jobs and their run order.
* *Lines 44-45:* These lines specify the first job, _Hello-World_.
* *Lines 46-48:* The syntax for the _Fetch-Code_ job is slightly different. The job name is followed by a `requires:`, then a _requires_ statement. This line specifies that the _Hello-World_ job must run successfully before the _Fetch-Code_ job is executed.
* *Lines 49-51:* The final job is _Using-Node_. As before, this job requires the successful completion of the previous job, _Fetch-Code_.

As before, commit and push your updated `config.yml` file.

In CircleCI, your pipeline will look different. Your workflow is now called _Example-Workflow_ and you have three jobs, rather than just one. 

image::config-intro-part3.png[Running multiple jobs]

If you click on the _Using-Node_ job and then the _Running the Node Container_ step, you should see that the command `node -v` has printed the version of Node.

image::config-node-job.png[Running Node job]

In this example, you have:

* Added comments to document your jobs.
* Created multiple jobs to run in different Docker containers.
* Created a workflow to define the order in which your jobs run.
* Introduced some logic to ensure that the previous job must complete successfully before the next job is executed.

TIP: To increase your understanding, experiment with other <<circleci-images#,CircleCI images>>, or add some more jobs to your workflow.

[#part-4-adding-a-manual-approval]
== Part 4: Adding a manual approval

The CircleCI workflow model is based on the orchestration of preceeding jobs. As you saw in Part 3, the `requires` statement specifies that a job should run only if the previous job has been successfully executed.

In Part 3, an event triggering the pipeline caused the `Hello-World` job to run immediately. The remaining jobs ran automatically, once `Hello-World` had completely successfully.

In this part, you will create a manual approval stage. This means subsequent jobs are executed only after you have approved the next step in the CircleCI app.

If you have not done so already, create a `.circleci` directory in your project, add a `config.yml` file, and type or paste the code from the example below:

[source,yaml]
----
version: 2.1
jobs:
  # running commands on a basic image
  Hello-World:
    docker:
      - image: alpine:3.15
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
    steps:
      - run:
          name: Saying Hello
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'
  # fetching code from the repo
  Fetch-Code:
    docker:
      - image: cimg/base:2021.04
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
    steps:
      - checkout
      - run:
          name: Getting the Code
          command: |
            ls -al
            echo '^^^Your repo files^^^'
  # running a node container
  Using-Node:
    docker:
      - image: cimg/node:17.2
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
    steps:
      - run:
          name: Running the Node Container
          command: |
            node -v
  Now-Complete:
    docker:
      - image: alpine:3.15
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
    steps:
      - run:
          name: Approval Complete
          command: |
            echo 'The work is now complete.'
       
workflows:
  Example-Workflow:
    jobs:
      - Hello-World
      - Fetch-Code:
          requires:
            - Hello-World
      - Using-Node:
          requires:
            - Fetch-Code
      - Hold-for-Approval:
          type: approval
          requires:
            - Using-Node
            - Fetch-Code
      - Now-Complete:
          requires:
            - Hold-for-Approval
----

Most of this code will look familiar to you. There are a couple of important additions:

* *Lines  64-68*: This creates a new job called _Hold-for-Approval_. The `type` specifies this is an _approval_, so you are required to manually approve this job in CircleCI. This is useful if you want to see whether the previous jobs have been executed as expected. For example, you can check that a website looks correct on a test server before making it live. Or you might want a human to perform checks before you execute any expensive jobs.
* *Lines 69-71*: This final job - _Now-Complete_ - `requires` the successful completion of _Hold-for-Approval_, so will execute only once you have approved that previous job in CircleCI.

As before, commit and push your updated `config.yml` file.

If you look at your pipeline in CircleCI, you will see the a purple status badge of *On Hold*. 

image::config-on-hold.png[Job requires approval]

To approve the job, click the thumbs up icon to the right of the _Hold-for-Approval_ job in the _Actions_ column. In the pop-up message, click the blue *Approve* button.

Now you will see a tick in the Actions column and your jobs should complete.

Click on the _Now-Complete_ job, then the _Approval Complete_ step. You should see the output of your command: `The work is now complete`.

image::config-approval-complete.png[Approval complete]

TIP: If you encounter errors, the problem is likely to be caused by incorrect indentation. The <<config-editor#,CircleCI Configuration Editor>> validates your syntax, provides autocomplete suggestions, and offers tips.

In this example, you have:

* Introduced some additional logic to control your workflow.
* Implemented the `approval` job type to require a manual approval within your workflow.

Using what you have learned above, you are ready to create some powerful pipelines.

[#see-also]
== See also

* <<configuration-reference#,Configuring CircleCI>>
* <<executor-intro#,Executors and Images>>
* <<workflows#,Using Workflows to Schedule Jobs>>


