---
layout: classic-docs
title: "データの永続化"
description: "CircleCI でデータを永続化する方法"
version:
  - Cloud
  - Server v2.x
---

ここでは、 CircleCI ビルド内外でデータを永続化する様々な方法を概説します。 ジョブ間およびジョブの内外にデータを移動したり、データを保持して後で使用するには複数の方法があります。 適切なタスクに適切な機能を使用することで、ビルドが高速化し、再現性と効率が向上します。

* 目次
{:toc}

## キャッシュの活用方法
{: #caching-strategies }

![キャッシュのデータ フロー]({{ site.baseurl}}/assets/img/docs/caching-dependencies-overview.png)

キャッシュにより、異なるワークフロー内のビルドにおける同じジョブのデータが保持され、高コストなフェッチ操作のデータを以前のジョブから再利用することができます。 ジョブを一回実行すると、その後のインスタンスでは同じ処理をやり直す必要がないため、実行が高速化されます（キャッシュが無効になっていない場合）。 わかりやすい例としては、Yarn や Bundler、Pip といった依存関係管理ツールが挙げられます。 キャッシュから依存関係を復元することで、yarn install などのコマンドを実行するときに、ビルドごとにすべてを再ダウンロードするのではなく、新しい依存関係をダウンロードするだけで済むようになります。

キャッシュは、プロジェクト内でグローバルに配置されます。 1 つのブランチに保存されたキャッシュが他のブランチで実行されるジョブでも使用されるため、キャッシュはブランチ間での共有に適したデータに対してのみ使用してください。

**save_cache ステップで作成されたキャッシュは、最長 15 日間保存されます。**

詳細については、[依存関係のキャッシュガイド]({{site.baseurl}}/ja/2.0/caching/)を参照してください。

## ワークスペースの使用
{: #using-workspaces }

![ワークスペースのデータ フロー]( {{ site.baseurl }}/assets/img/docs/workspaces.png)

ジョブ内でワークスペースが宣言されていると、ファイルやディレクトリを追加することができます。 追加するたびにワークスペースのファイルシステム内に新しいレイヤーが作成されます。 ダウンストリーム ジョブで必要に応じてこのワークスペースを使用したり、レイヤーをさらに追加することができます。

ワークスペースは異なるパイプラインの実行において共有されません パイプラインの実行後にワークスペースにアクセスできるのは、ワークフローが 15 日以内に再実行された場合のみです。

**ワークスペースは最長で15日間保存されます。**

ワークスペースを使用してワークフロー全体のデータを保持する方法の詳細については、[ワークフローガイド]({{site.baseurl}}/ja/2.0/workflows/#using-workspaces-to-share-data-among-jobs)をご覧ください。 [CircleCI のワークスペースの詳細](https://circleci.com/ja/blog/deep-diving-into-circleci-workspaces/)に関するブログ記事もご覧ください。

## アーティファクトの使用
{: #using-artifacts }

![アーティファクトのデータ フロー]( {{ site.baseurl}}/assets/img/docs/Diagram-v3-Artifact.png)

アーティファクトは、パイプラインの出力を長期保存するために使用されます。 たとえば Java プロジェクトを使用している場合、ビルドにより多くの場合、コードの` .jar `ファイルが生成されます。 このコードはテストによって検証されます。 ビルドやテストプロセスがすべて成功した場合は、プロセスの出力（` .jar `）をアーティファクトとして保存できます。 この `jar `ファイルは、ファイルを作成したワークフローの終了後も長期間アーティファクトシステムからダウンロードできます。

プロジェクトをパッケージ化する必要がある場合は、`.apk` ファイルが Google Play にアップロードされる Android アプリを使用して、アーティファクトとして保存することをお勧めします。 多くのユーザーがアーティファクトを Amazon S3 や Artifactory などの全社的な保存先にアップロードしています。

**アーティファクトは最長で 30 日間保存されます。**

アーティファクトを使用してジョブの完了後にデータを保持する方法の詳細については、[ビルドアーティファクトの保存方法]({{site.baseurl}}/ja/2.0/artifacts/)を参照してください。

## ネットワークとストレージ使用の管理
{: #managing-network-and-storage-use }

### ストレージとネットワーク転送の概要
{: #overview-of-storage-and-network-transfer }

ジョブ内でデータを保持するための操作には、ネットワークとストレージの使用が発生します。関連するアクションは次のとおりです。

* キャッシュのアップロードとダウンロード
* ワークスペースのアップロードとダウンロード
* アーティファクトのアップロード
* テスト結果のアップロード

上記のアクションを行うジョブを決定するには、プロジェクトの config.yml ファイルで次のコマンドを検索します。

* `save_cache`
* `restore_cache`
* `persist_to_workspace`
* `store_artifacts`
* `store_test_results`

すべてのネットワーク転送にはネットワークの使用が発生します。関連するアクションは次のとおりです。

* キャッシュとワークスペースのセルフホストランナーへの復元
* アーティファクトのダウンロード
* CircleCI 外のジョブからのデータプッシュ

ストレージとネットワーク転送の使用状況の詳細は、プラン > プランの使用状況画面で確認できます。

* ネットワークとストレージの総使用量は、画面上部の表に表示されます。
* 個々のプロジェクトのネットワークとストレージの使用状況は、 [Project (プロジェクト)] タブに表示されます。
* ストレージデータアクティビティは、 [Object (オブジェクト)] タブに表示されます。
* 総ストレージ量のデータは[Strage (ストレージ)]タブに表示されます。

![plan-usage-screen]( {{ site.baseurl }}/assets/img/docs/screen-plan-usage.png)

個々のステップのストレージおよびネットワーク転送の使用方法の詳細については、以下のジョブページのステップ出力を参照してください。

![save-cache-job-output]( {{ site.baseurl }}/assets/img/docs/job-output-save-cache.png)

### ストレージとネットワーク転送の使用の管理方法
{: #how-to-manage-your-storage-and-network-transfer-use }

ストレージとネットワークの使用を最大限に活用するために設定を最適化する一般的な方法は複数あります。

データ使用量の削減を試みる前に、まずそのデータの使用を維持する価値が十分にあるかどうかを検討してください。 キャッシュとワークスペースの場合、比較が非常に簡単です。キャッシュによる開発 / 計算時間の節約は、ダウンロードとアップロードのコストを上回っていますか？ ストレージとネットワークの最適化例については、以下をご覧ください。

### アーティファクトやキャッシュ/ワークスペースのトラフィックを減らす方法
{: #opportunities-to-reduce-artifact-and-cacheworkspace-traffic }

#### アップロードされているアーティファクトの確認
{: #check-which-artifacts-are-being-uploaded }

実際に必要なファイルがわずかでも、store_artifacts ステップが大きなディレクトリで使用されているケースがよくあります。その簡単な対策として、どのアーティファクトがなぜアップロードされているかをご確認ください。

ジョブで並列処理を使用している場合は、各並列タスクが同じアーティファクトをアップロードしている可能性があります。 実行ステップで CIRCLE_NODE_INDEX 環境変数を使用して並列タスクの実行に応じてスクリプトの動作を変更することができます。

#### 大きなアーティファクトのアップロード
{: #uploading-large-artifacts }

* テキスト形式のアーティファクトは、非常に低いコストで圧縮できます。
* UI テストのイメージや動画をアップロードする場合は、フィルタを外し、失敗したテストのみをアップロードします。 多くの組織では UI テストからすべてのイメージをアップロードしていますが、その多くは使用されません。
* パイプラインがバイナリの Uber JAR をビルドしている場合、コミットのたびにそれが必要なのかどうかを検討してください。 フィルタを使用して失敗時または成功時のみアーティファクトをアップロードする、または単一のブランチにのみアーティファクトをアップロードすることが可能です。
* 大きなアーティファクトをアップロードする必要がある場合、ご自身のバケットに無料でアップロードすることが可能です。

#### 未使用または余分な依存関係のキャッシュ
{: #caching-unused-or-superfluous-dependencies }

ご使用の言語およびパッケージ管理システムによっては、不要な依存関係をクリアまたは「削除」するツールを利用できる場合があります。 たとえば、 node-prune パッケージは、 node_modules から不要なファイル (マークダウン、TypeScript ファイルなど) を削除します。

#### キャッシュ使用率の最適化
{: #optimizing-cache-usage }

キャッシュの使用率が高く使用率を下げたい場合は以下をお試しください。

* config.yml ファイルで `save_cache` コマンドと `restore_cache` コマンドでキャッシュを使用するすべてのジョブを検索し、キャッシュの削除が必要かどうかを判断する。
* キャッシュの範囲を大きなディレクトリから特定のファイルの小さなサブセットに縮小する。
* キャッシュの「キー」が[ベストプラクティス]({{ site.baseurl}}/ja/2.0/caching/#further-notes-on-using-keys-and-templates)に従っているかを確認する。

{% raw %}
```sh
       - save_cache:
         key: brew-{{epoch}}
         paths:
           - /Users/distiller/Library/Caches/Homebrew
           - /usr/local/Homebrew
```
{% endraw %}

上記の例は、ベストプラクティスに従っていません。 `brew-{{ epoch }}` はビルドごとに変更され、値が変更されていない場合でも毎回アップロードされます。 この方法では結局コストもかかり、時間も短縮できません。 代わりに、次のようなキャッシュキーを選択します。

{% raw %}
```sh
     - save_cache:
         key: brew-{{checksum “Brewfile”}}
         paths:
           - /Users/distiller/Library/Caches/Homebrew
           - /usr/local/Homebrew
```
{% endraw %}

この場合、要求された依存関係のリストが変更された場合にのみ変更されます。 これでは新しいキャッシュのアップロードの頻度が十分でないという場合は、依存関係にバージョン番号を含めます。

* キャッシュをやや古い状態にします。 新しい依存関係がロックファイルに追加された時や依存関係のバージョンが変更された時に新しいキャッシュがアップロードされる上記の方法とは対照的に、あまり正確に追跡しない方法を用います。

* アップロードする前にキャッシュを削除しますが、キャッシュキーを生成するものはすべて削除してください。

#### ワークスペースの使用率の最適化
{: #optimizing-workspace-usage }

ワークスペースの使用率が高く使用率を下げたい場合、以下をお試しください。

* config.yml ファイルで`persist_to_workspace `コマンドを検索し、ワークスペースを使用するすべてのジョブを検索し、パス内のすべてのアイテムが必要かどうかを判断します。

#### ネットワーク転送の過剰な使用を減らす
{: #reducing-excess-use-of-network-egress }

ネットワーク転送が原因となっているネットワークの使用量を減らすには、以下をお試しください。

* Runner の場合は、 AWS US-East-1 にクラウドベースのランナーをデプロイします。
* アーティファクトを 1 度ダウンロードし、ご自身のサイトに保存して処理を追加します。
