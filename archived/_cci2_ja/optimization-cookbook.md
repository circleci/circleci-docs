---
layout: classic-docs
title: "CircleCI 最適化クックブック"
short-title: "最適化クックブック"
description: "最適化クックブック入門編"
categories:
  - はじめよう
order: 1
version:
  - クラウド
  - Server v3.x
  - Server v2.x
---

*CircleCI 最適化クックブック*は、**パイプライン** (コードの変更をユーザーに届けるためのメカニズム) を最適化するための詳しい手順をユースケースごとにまとめた「レシピ集」です。 ビルドの高速化やセキュリティーの強化につながるパイプラインの最適化により、組織の全体的な開発および運用の KPI にプラスの影響を与えます。

このクックブックを参照することで、繰り返し実行可能な最適化タスクをすばやく簡単に CircleCI プラットフォームで実行できるようになります。

* 目次
{:toc}

## はじめに
{: #introduction }

CircleCI プラットフォームを使用しているときに、パイプラインのパフォーマンスに予期せぬ遅れが発生し、構造化されている重要な動作の実行性能に悪影響を及ぼす場合があります。 こうしたパフォーマンスのボトルネックは、全体のパフォーマンスに影響するだけでなく、ワークフローやビルドの失敗の原因にもなります。 一見、軽微なトラブルのように思えますが、それぞれのボトルネックを解消するためにクレジットやリソース、時間などを費やすことになり、コストがかさんでしまいます。

## キャッシュを利用してビルドとワークフローを最適化する
{: #using-caching-to-optimize-builds-and-workflows }

ビルドとワークフローを最適化する一番の早道は、具体的なキャッシュ戦略を実践して、以前のビルドとワークフローで生成された既存のデータを利用できるようにすることです。 パッケージ管理アプリケーション (Yarn、Bundler など) を使用する場合でも、キャッシュ処理を手動で設定する場合でも、最も適正で効果的なキャッシュ戦略を用いることにより、パフォーマンス全体の向上を図ることができます。

ジョブで任意の時点のデータをフェッチする場合は、キャッシュを利用できる可能性があります。 一般的によく用いられるのが、パッケージ マネージャーや依存関係管理ツールです。 たとえば、プロジェクトで Yarn、Bundler、Pip などを利用すると、ジョブの実行中にダウンロードする依存関係は、ビルドのたびに再ダウンロードされるのではなく、後で使用できるようにキャッシュされます。

依存関係のキャッシュのサンプルは、[最適化]({{site.baseurl}}/2.0/optimizations/#caching-dependencies)のページを参照して下さい。 _注: データの永続化は、プロジェクト固有であり、最適化のページにあるサンプルはお客様のプロジェクトにカスタマイズをせずにそのままコピー & ペーストするためのものではありません。_

キャッシュはビルドとワークフローを最適化するための非常に重要な側面であるため、まずは[キャッシュ]({{site.baseurl}}/2.0/caching/)のページの説明をよく理解することをお勧めします。このページでは、キャッシュについて説明すると共に、設定ファイルを最適化するためのさまざまな戦略を紹介しています。

## テストパフォーマンスを向上させる
{: #improving-test-performance }

CircleCI プラットフォームでテストを実行するには、テストプロセスを最適化して、いかにクレジットの使用量を最小限に抑えながらテストパフォーマンス全体と結果を改善するかを検討する必要があります。 テストによっては、非常に時間がかかったり、高いパフォーマンスが必要になったりします。そのため、テスト時間を短縮できれば、組織の目標達成に向けて大きな後押しとなります。

CircleCI プラットフォームでテストを行う際には、多様なテスト スイートやアプローチを採用できます。 CircleCI はテスト スイートに依存しませんが、以下の例 ([こちらのブログ記事](https://www.brautaset.org/articles/2019/speed-up-circleci.html)でこのテスト最適化ユース ケースについて説明している開発者から許可を得て改変) では、Django と CircleCI プラットフォームでテストを最適化する方法を説明します。

### CircleCI プラットフォームでの Python Django プロジェクトのテストを最適化する
{: #testing-optimization-on-the-circleci-platform-for-a-python-django-project }
{:.no_toc}

CircleCI で各変更をメインブランチにマージする前にテストを実行している組織もあります。 テストを高速化すると、フィードバックサイクルが速く回るようになり、自信を持ってコードを頻繁にリリースできるようになります。 Python Django アプリケーションのワークフローの例を見てみましょう。CircleCI プラットフォームでテストを完了するのに 13 分以上かかっています。

テストプロセスは以下のように表示されます。

![最適化する前のテスト最適化プロセス]({{site.baseurl}}/assets/img/docs/optimization_cookbook_workflow_optimization_1.png)

それでは、上図のテストプロセスを細かく見て、テストの完了までにかかった時間を確認してみましょう。

テスト中には以下のステップが実行されました。

1. ビルドジョブで、ランタイムの依存関係のみを含む Docker イメージを作成
2. ビルドジョブで、そのイメージを `docker save` でファイルにダンプし、ワークスペースで永続化
3. 2 つのテストジョブを実行し、ベースイメージをワークスペースからリストア
4. 各テストジョブで、このベースイメージを基にして、テストの実行に必要なすべての追加モジュールを含むイメージを作成
5. 各テストジョブで、依存関係を開始し、最終的にテストを実行

通常、セットアップを 1 回実行してから `fan out` ステップを実行する方法が、リソースの使用量を削減する方法として従来から用いられています。ただしこの例では、次のように`fan out` ステップで非常にコストがかかっていることが判明しました。

- ビルド済みイメージをファイルにダンプする `docker save` の発行に、約 **30** 秒かかっている。
- ワークスペースへのイメージの保存に、さらに **60** 秒かかっている。
- 次に、テスト ジョブでワークスペースをアタッチしてベース イメージを読み込む処理に、さらに **30** 秒かかっている。
- テスト ジョブで `docker-compose` を実行して依存関係に従ってサービス (Redis、Cassandra、PostgreSQL) を開始するときに Machine Executor を使用しており、 Docker Executor と比較して起動時間に **30 ～ 60** 秒が余計にかかっている。
- ビルド ジョブのベース イメージにはランタイムの依存関係のみが含まれていたため、これを拡張してテスト用の依存関係を追加して Docker イメージをビルドする必要があり、 この処理にさらに **70** 秒かかっている。

このように、実質的にテストを実行していないセットアップの段階でかなりの時間がかかっています。 このプロセスでは、実際のテストが実行されるまでに 6.5 分を必要とし、さらにもう 1 つのテスト ジョブの実行までに 6.5 分を要していました。

### テストの準備を最適化する
{: #test-preparation-optimization }
{:.no_toc}

このワークフローのステップの実行に 13 分は長すぎるため、以下の方法を実行して最適化および時間を短縮しました。

#### CI テストのワークフローの変更
{: #changing-the-ci-test-workflow }
{:.no_toc}

ベースイメージのビルドを行わないように、CI テス ワークフローを変更しました。 テスト ジョブも変更し、`docker-compose` を使用するのではなく、CircleCI の Docker Executor に備わっているサービスコンテナサポートを使用して補助サービスを起動するようにしました。 さらに、メイン コンテナから `tox` を実行して、依存関係のインストールとテストの実行を行うようにすることで、イメージを保存してワークスペースからリストアするのに要していた時間を削減しました これにより、Machine Executor の起動にかかる余分なコストも削減されました。

#### 依存関係の変更
{: #dependency-changes }
{:.no_toc}

Dockerfile を使用するのではなく、CircleCI のプライマリコンテナに依存関係をインストールすると、CircleCI のキャッシュ機能によって `virtualenv` の作成を高速化できる場合があります。

### テストの実行を最適化する
{: #test-execution-optimization }
{:.no_toc}

上記の手順により、テストの準備時間が短縮されました。次は、実際のテストの実行を高速化しましょう。 たとえば、テストの実行後にデータベースを保持する必要がない場合もあります。 テストを高速化するための一つの方法は、テストに使用するデータベースのイメージを[ディスクに保存されないメモリ内 Postgres イメージ]({{site.baseurl}}/2.0/databases/#postgresql-database-testing-example) に置き換えることです。 もう一つは、一度に一つのテストをする代わりに[テストを並列実行]({{site.baseurl}}/2.0/parallelism-faster-jobs/)する方法です。

これらの変更によってワークフロー全体の時間がどれだけ短縮されたかは下図のとおりです。

![最適化した後のテスト最適化プロセス]({{site.baseurl}}/assets/img/docs/optimization_cookbook_workflow_optimization_2.png)

ここまで見てきたように、1 つの変更だけでワークフロー全体の時間を短縮したわけではありません。 たとえば、時間の大部分がテストの準備に費やされていたら、テストを並列実行してもそれほどメリットはなかったでしょう。 ローカルの環境ではなく CircleCI プラットフォームでテストを実行することの違いを認識し、テストの準備と実行にいくつかの変更を加えることでテストの実行時間を改善できます。

## テストを分割してパイプラインを高速化する
{: #test-splitting-to-speed-up-pipelines }

パイプラインは、一般的にコードがコミットされるたびに一連のテストが実行されるように設定されます。 テストの分割は、CICD パイプラインのテスト部分を高速化できる優れた方法です。 テストは、常に順番に実行する必要はありません。一連のテストは、並行して実行されるさまざまなテスト環境に分割することができます。

テスト分割を使用すると、名前やサイズなどによって、テストスイートのどこで分割するのかをインテリジェントに定義できます。 **タイミングベース**のテスト分割を使用すると、前回のテスト実行のタイミングデータを使用して、並行して実行されている指定された数のテスト環境でできるだけ均等にテストスイートを分割し、使用中の計算能力のテスト時間を最小限に抑えることができます。

![テストの分割]({{ site.baseurl }}/assets/img/docs/test_splitting.png)

### 並列実行とテスト分割
{: #parallelism-and-test-splitting }
{:.no_toc}

順次実行されるテストスイートを使って、これを CI 設定で説明します。すべてのテストは、単一のテスト環境（ Docker コンテナ）で実行されます。

```yaml
jobs:
  build:
    docker:
      - image: buildpack-deps:trusty
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
    environment:
      FOO: bar
    resource_class: large
    working_directory: ~/my-app
    steps:
      - run: go test

```

これらのテストを分割するには、タイミングデータを使用して、まず並列実行により同一のテスト環境の数（この場合は 10 ）をスピンアップします。 次に、 `--split-by=timings` フラグを指定して `circleci tests split` コマンドを使用して、すべての環境で可能な限り均等にテストを分割し、スイート全体が最短時間で実行されるようにします。

```yaml
jobs:
  build:
    docker:
      - image: buildpack-deps:trusty
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
    environment:
      FOO: bar
    parallelism: 10
    resource_class: large
    working_directory: ~/my-app
    steps:
      - run: go test -v $(go list ./... | circleci tests split --split-by=timings)
```

**注: **テストを初めて実行するときは、コマンドで使用するタイミングデータがありませんが、その後の実行ではテスト時間が最適化されます。

### 効果は？
{: #is-it-worth-it }
{:.no_toc}

このタイミングによる分割機能の効果を定量的に示すために、 CircleCI アプリケーションプロジェクト全体で実行されるテストスイートに`並列実行 :10`を追加すると、実際にテスト時間が **26:11 から 3:55** に短縮されました。

テストスイートは、名前またはサイズで分割することもできますが、タイミングベースのテスト分割を使用すると、最も正確に分割することができ、各テストスイートの実行時に間違いなく最適化されます。分割する場所の定義には、常に最新のタイミングデータが使用されます。 詳細は、[並列実行を使ってジョブのテストを高速化する]({{site.baseurl}}/2.0/parallelism-faster-jobs/)を参照して下さい。

## ワークフローによりデプロイ頻度を上げる
{: #workflows-increase-deployment-frequency }

顧客に価値を提供することは、あらゆる組織にとって最優先の目標であり、組織のパフォーマンスは、価値が提供される頻度 (デプロイ頻度) により測ることができます。 DevOps Research and Assessment Report  (2019 年) によれば、パフォーマンスの高いチームは、 1 日に何度も顧客に価値を提供しています。

多くの組織では、四半期に 1 回、または月に 1 回、顧客に価値を提供していますが、この頻度を週に 1 回または 1 日に 1 回に上げるための基本的な方法は、組織の価値、つまり*パイプライン* に追加される同じタイプのオーケストレーションです。

開発者は、1 日に何度もデプロイするために、メインブランチにいなくても、メインの環境に正確に一致するコードブランチで変更をテストできる自動化されたワークフローを必要としています。 これは、継続的インテグレーションスイートでワークフローのオーケストレーションを使用することにより実現できます。

{%comment %}![Workflow without Deploy]({{ site.baseurl }}/assets/img/docs/workflows-no-deploy.png){%
endcomment %}

メイン環境ですべてのテストのみ実行し、デプロイは実行しないワークフローを提供することにより、開発者はすべてのテストが成功するまで、ブランチでコードを安全にテストおよびデバッグすることができます。

{%comment %}![Workflow with Deploy]({{ site.baseurl }}/assets/img/docs/workflows-yes-deploy.png){%
endcomment %}

すべてのテストを*メインにあるかのように*実行するワークフローにより、開発者はコードの破損や顧客のサービスが中断されることがないことがわかっているため、安心してメインにマージすることができます。 このようなワークフローに対する小さな投資により、顧客にとって重要な変更のデプロイ頻度を増やすことができます。

シンプルな例として、変更がメインにマージされ、テストジョブがすでに成功している場合*のみ*、デプロイを実行するように設定します。

この設定は、1 日に何度もデプロイする組織では下記の YAML スニペットのようにシンプルです。

```yaml
workflows:
  build-test-deploy:
    jobs:
      - build
      - test
      - deploy:
          requires:
            - build
          filters:
            branches:
              only: main
```


上記の方法でワークフローを*使用していない*組織のデプロイ頻度の時間の差には、開発者の環境と本番環境を同じ環境にするために必要な時間が含まれます。また、コードに問題がないことを確認するために同じテストをすべて実行する時間も含まれます。 メインに他の変更を加える前に、すべての開発者がすべての環境の更新とテストを完了しなければなりません。 環境の更新中または独自のテストの実行中に*メインで*変更があった場合、コードの破損がないことを確認するためにすべてを再実行しなければなりません。

ゆっくりとしたペースでデプロイする組織の場合、夜間にビルドワークフローを設定し、顧客がアップデートを必要とする日にテスト済みのデプロイ可能なビルドを提供することができます。

```yaml
workflows:
  nightly-build:
    triggers:
      - schedule:
          cron: '0 8 ***'
          filters:
            branches:
              only: main
    jobs:
      - build
      - test
      - deploy
```

時間の差には、上記で説明した時間に加え、開発者が変更を完了してからスケジュール化されたビルドが実行されるまでのパイプラインの実行時間と経過時間も含まれます。 これらの時間を合わせると、開発者はコードの品質に対する信頼性を高めることができ、デプロイ頻度を高めることができます。


## 関連項目
{: #see-also }
{:.no_toc}

- [最適化]({{site.baseurl}}/2.0/optimizations): キャッシュ、ワークフロー、ビルドに対して実践できるその他の最適化戦略
- [依存関係のキャッシュ]({{site.baseurl}}/2.0/caching/#はじめに): キャッシュの概要
